---
id: why-powertree
title: Why PowerTree?
---

### Serverless objects instead of servers and services
This is BIG! No need to set up virtual machines, networks, clusters, containers, processes, servers, components, etc. No need to implement, maintain and operate complex service deployments. PowerTree allows developers to just focus on their application logic and not having to worry about who, where and how is deploying and hosting their code. Most developers are well trained and versed in object oriented programming so such programming model comes natural to them. Service oriented architectures on the other hand are difficult to implement, test and operate. PowerTree offers an alternative approach where developers write the type of code they are used to. This is the fundamental promise behind distributed actor programing models and PowerTree fully embraces and delivers on that promise. 
	
### Effortless distributed parallel computing at scale
Writing parallel programs is hard. Writing distributed programs is hard. Writing parallel distributed programs running at large scale is really, really hard! Most developers would not be able to deal with such high level of complexity with traditional or sometimes even with modern software tools. But this is where the PowerTree platform excels. It makes writing highly parallelized programs running on large number of servers fairly easy. Thanks to the PowerTree simple programming model developers can easily parallelize their programs and let the PowerTree platform do the rest. The runtime will hide all details around hosting the program and efficiently utilize all available hardware resources to get the job done as quickly as possible. Not only that but PowerTree allows developers to easily test their parallel programs on their dev boxes or development environments where testing, profiling and debugging is much cheaper that in actual production, cloud and on-premise environments. 

### Flexible, scalable architecture
PowerTree is extremely versatile. It can be hosted within a single, existing process. Or, it can run on multiple clusters and thousands of servers. It can run within a unit testing framework, or interactive PowerShell session, or JIT deployed and activated on remote machines that never had PowerTree deployed before. It can run on a dev box, on-premise and cloud environments on bare metal or virtual machines, Service Fabric or Kubernetes clusters. The list goes on and on. At the core of PowerTree's flexibility is its simple, componentized architecture and its small footprint, portable runtime. The cost of getting started by hosting PowerTree in-process is negligible. There are no expensive setups to run, external dependencies or large files to deploy. Only copy the runtime binaries, write a few lines of code and you are up and running. Of course, scaling from smaller to larger architectures like multiple compute and storage nodes requires more investments but they are incremental. There is no falling off a cliff while scaling a PowerTree system. 
 
### Durability
Distributed systems often have to deal with unexpected, non-deterministic failures that are difficult to handle correctly. Distributed PowerTree applications are shielded to a large degree from multiple classes of distributed system errors like process, machine and network failures. The platform supports frequent state persistence which allows it to identify and retry only a small, failed portion instead of allowing the entire application to fail. The system utilizes all available hardware resources to continue operating even under severe stress and failure conditions and continue to make forward progress. This makes it extremely valuable in a broad range long running automation scenarios that require high levels of reliability.

### Actual component model that delivers
### Seamless deployments
### Great code-first developer experience
### Resource utilization via intelligent load balancing
### Great DevOps/Ops experience 
